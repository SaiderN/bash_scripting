## Переменные
Переменным можно присваивать различные значения:
Числовое значение `x=2` или стринговое значение `x=hi`. Всё пишется слитно с переменной и равно.

**(дополнение)**
### Типы данных в Bash
Bash по своей сути — это оболочка для запуска команд, и она **не имеет строгой типизации** как, например, C++ или Java. Все переменные по умолчанию хранятся как строки (strings). Однако контекст их использования (в арифметических операциях, сравнениях) определяет, как они интерпретируются.

**Основные "типы" на практике:**
1.  **Строка (String):** Значение по умолчанию. `name="Alice"`, `path="/usr/bin"`
2.  **Целое число (Integer):** Для арифметических операций. Создаётся не объявлением, а использованием в арифметическом контексте: `count=5` (хранится как строка "5", но может использоваться как число).
3.  **Массив (Array):** Индексированный список значений. `files=(file1.txt file2.txt)`
4.  **Ассоциативный массив (Associative Array):** Пары "ключ-значение" (как словарь). `declare -A user=([name]="John" [id]=123)`
5.  **"Булевы" значения:** Прямых `true`/`false` нет. Успех или неудача операции определяется **кодом возврата** (`0` = истина/успех, **любое не-нулевое значение** = ложь/ошибка). Для проверок часто используют команды `true` (всегда возвращает 0) и `false` (всегда возвращает 1).

**(дополнение)**
### Объявление и атрибуты переменных
Хотя явно объявить тип `int` нельзя, команда `declare` (или её синонимы `typeset`) позволяет задать переменной особые *атрибуты*, влияющие на её поведение.

```bash
#!/bin/bash

# -i : Интерпретировать переменную как целое число (integer) в арифметических операциях.
declare -i number
number="10"   # Строка "10" будет преобразована в число 10
number="hello" # Если присвоить не-число, оно станет 0
echo $number   # Выведет 0

# -r : Сделать переменную только для чтения (readonly/константа).
declare -r PI=3.14159
# PI=3.14 # Эта строка вызовет ошибку: "readonly variable"

# -a : Объявить индексированный массив.
declare -a colors=("red" "green" "blue")
echo ${colors[1]} # Выведет "green" (индексация с 0)

# -A : Объявить ассоциативный массив (требует Bash версии 4.0+).
declare -A user
user[name]="Bob"
user[age]=25
echo ${user[name]} # Выведет "Bob"

# -x : Экспортировать переменную в окружение для дочерних процессов.
declare -x MY_TOOL_PATH="/opt/mytool"
# Теперь переменная MY_TOOL_PATH будет доступна в любом скрипте, запущенном из этого.
```
### Вывод с командой echo:
Если хотим просто вывести переменную : `echo $x` (то есть само использование переменной выражается через знак доллара). Но также мы можем использовать несколько переменных сразу. Например echo $x $name.
Не стоит забывать, что, если мы хотим использовать текст в выводе, нужно помещать все значения в ДВОЙНЫЕ!!! кавычки : `echo "Hi $name . I am $x y.o. And you?"`

С одинарными кавычками переменная не активируется и мы просто выведем текст ( название переменной, вместо её значения).

**Особенности**
Мы можем пользоваться функционалом переменных и в других языках программирования, правда есть фишки вроде того что мы не можем прописать `new=$x+$y` мы получим строковый ответ `2+1`, так как изначально все переменные строковые поэтому мы вычислительное выражение помещаем в две скобки `new=$(($x+$y))`.

## Арифметические операции: подробнее
**Для работы с числами есть несколько способов:**

```bash
x=5
y=3

# Способ 1: $(( ... )) (основной, рекомендуется)
sum=$(($x + $y))       # 8
diff=$((x - y))        # 2. Обрати внимание: знак $ перед именами внутри (()) можно опустить!
mult=$((x * y))        # 15
div=$((x / y))         # 1 (целочисленное деление!)

# Способ 2: let
let "sum = x + y"      # 8
let "x++"              # Инкремент. Теперь x=6

# Способ 3: expr (устаревший, но встречается)
sum=`expr $x + $y`     # 8 (используются обратные кавычки)
```

**Работа со строками**

```bash
text="Hello World"

# Длина строки
echo ${#text}          # 11

# Конкатенация (сложение строк)
greet="Hello, "$name"!" # Или: greet="Hello, ${name}!"

# Извлечение подстроки
echo ${text:0:5}       # "Hello" (с позиции 0 взять 5 символов)
echo ${text:6}         # "World" (с позиции 6 до конца)

# Замена в строке (только первое вхождение)
echo ${text/World/Bash} # "Hello Bash"
# Замена всех вхождений
echo ${text//l/_}      # "He__o Wor_d"
```

**Коды возврата и булева логика**
В Bash "истина" — это код возврата 0, "ложь" — любое число от 1 до 255.

```bash
# Команда 'true' всегда возвращает 0 (успех), 'false' всегда возвращает 1 (ошибка).
if true; then
  echo "Это всегда выполнится"
fi

# Проверка условий осуществляется командами test или [[ ... ]]
x=10
y=20

if [[ $x -lt $y ]]; then  # -lt = less than (<)
  echo "$x меньше $y"
fi

# Логические операции И (&&), ИЛИ (||)
[[ $x -gt 5 ]] && [[ $y -lt 30 ]] && echo "Оба условия истинны"

# Проверка кода возврата последней команды
ls /some/nonexistent/directory
if [[ $? -ne 0 ]]; then  # $? содержит код возврата. -ne = not equal (!=)
  echo "Последняя команда завершилась с ошибкой."
fi
```

**Область видимости (Scope)**
По умолчанию переменные глобальны. Чтобы сделать переменную локальной для функции, используйте ключевое слово `local`.

```bash
global_var="I am global"

my_function() {
  local local_var="I am local"
  global_var="Changed inside function"
  echo "Inside: $local_var, $global_var"
}

my_function
echo "Outside: $local_var, $global_var"
# Выведет:
# Inside: I am local, Changed inside function
# Outside: , Changed inside function
# (local_var пуста, так как она существовала только внутри функции)
```

### Специальные переменные окружения

Bash автоматически устанавливает ряд полезных переменных окружения. Они доступны в любом скрипте:

- **`BASH`** — полный путь до исполняемого файла Bash.  
  `echo "Я работаю в: $BASH"`

- **`BASH_VERSION`** — версия Bash.  
  `echo "Версия оболочки: $BASH_VERSION"`

- **`HOME`** — домашний каталог текущего пользователя.  
  `echo "Домашняя папка: $HOME"`

- **`HOSTNAME`** — имя компьютера (хоста).  
  `echo "Имя машины: $HOSTNAME"`

- **`RANDOM`** — возвращает случайное число от 0 до 32767 при каждом обращении.  
  `echo "Случайное число: $RANDOM"`

- **`OSTYPE`** — тип операционной системы.  
  `echo "ОС: $OSTYPE"`

- **`PWD`** — текущий рабочий каталог (от **P**rint **W**orking **D**irectory).  
  `echo "Текущая папка: $PWD"`

- **`PS1`** — строка приглашения командной оболочки (то, что ты видишь перед курсором).  
  `echo "Мое приглашение: $PS1"`

- **`UID`** — числовой ID текущего пользователя (0 для root).  
  `[[ $UID -eq 0 ]] && echo "Ты root!" || echo "Ты обычный пользователь"`

- **`USER`** — имя текущего пользователя.  
  `echo "Привет, $USER!"`

**Пример использования:**
```bash
#!/bin/bash
echo "Пользователь $USER (ID: $UID) запустил скрипт из $PWD"
echo "Хост: $HOSTNAME, ОС: $OSTYPE, Bash: $BASH_VERSION"
echo "Сгенерируем случайное число для лотереи: $RANDOM"
```

### Ввод значений во время выполнения скрипта: Команда read
Позволяет получить ввод от пользователя (с клавиатуры) и сохранить его в переменную.

**Базовый синтаксис:**

```bash
read variable_name
После выполнения скрипт ждёт, пока пользователь введёт текст и нажмёт Enter.
```
Пример:

```bash
#!/bin/bash
echo "Как тебя зовут?"
read username
echo "Привет, $username! Добро пожаловать в скрипт."
```
**Дополнительные возможности read:**

```bash
# 1. Запрос с подсказкой (prompt)
read -p "Введите ваш возраст: " age
echo "Вам $age лет"
# 2. Скрытный ввод (для паролей)
read -s -p "Введите пароль: " password
echo  # перенос строки после скрытого ввода
echo "Пароль принят (но не покажу его!)"
# 3. Ввод нескольких значений
read -p "Введите имя и фамилию: " first_name last_name
echo "Имя: $first_name, Фамилия: $last_name"
# 4. Ограничение времени ввода (таймаут)
read -t 10 -p "У вас 10 секунд на ответ: " quick_answer
echo "Вы сказали: ${quick_answer:-ничего}"
```

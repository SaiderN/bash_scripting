# bash_scripting
Записная инструкция и готовые проекты c bash скриптами

## Типичный bash-скрипт имеет простую структуру:

1. **Shebang (#!)**. Первая строка указывает интерпретатор, который будет использоваться, обычно Bash.( `#!/bin/bash`)
2. **Команды**. Серия допустимых команд оболочки, записанных по одной строке.

## Затем чтобы сделать скрипт исполняемым прописываем:
`chmod +x (путь к файлу)` - это даёт разрешение на исполнение

Запускается просто: `./script.sh`

## Переменные
Переменным можно присваивать различные значения:
Числовое значение `x=2` или стринговое значение `x=hi`. Всё пишется слитно с переменной и равно.

**(дополнение)**
### Типы данных в Bash
Bash по своей сути — это оболочка для запуска команд, и она **не имеет строгой типизации** как, например, C++ или Java. Все переменные по умолчанию хранятся как строки (strings). Однако контекст их использования (в арифметических операциях, сравнениях) определяет, как они интерпретируются.

**Основные "типы" на практике:**
1.  **Строка (String):** Значение по умолчанию. `name="Alice"`, `path="/usr/bin"`
2.  **Целое число (Integer):** Для арифметических операций. Создаётся не объявлением, а использованием в арифметическом контексте: `count=5` (хранится как строка "5", но может использоваться как число).
3.  **Массив (Array):** Индексированный список значений. `files=(file1.txt file2.txt)`
4.  **Ассоциативный массив (Associative Array):** Пары "ключ-значение" (как словарь). `declare -A user=([name]="John" [id]=123)`
5.  **"Булевы" значения:** Прямых `true`/`false` нет. Успех или неудача операции определяется **кодом возврата** (`0` = истина/успех, **любое не-нулевое значение** = ложь/ошибка). Для проверок часто используют команды `true` (всегда возвращает 0) и `false` (всегда возвращает 1).

**(дополнение)**
### Объявление и атрибуты переменных
Хотя явно объявить тип `int` нельзя, команда `declare` (или её синонимы `typeset`) позволяет задать переменной особые *атрибуты*, влияющие на её поведение.

```bash
#!/bin/bash

# -i : Интерпретировать переменную как целое число (integer) в арифметических операциях.
declare -i number
number="10"   # Строка "10" будет преобразована в число 10
number="hello" # Если присвоить не-число, оно станет 0
echo $number   # Выведет 0

# -r : Сделать переменную только для чтения (readonly/константа).
declare -r PI=3.14159
# PI=3.14 # Эта строка вызовет ошибку: "readonly variable"

# -a : Объявить индексированный массив.
declare -a colors=("red" "green" "blue")
echo ${colors[1]} # Выведет "green" (индексация с 0)

# -A : Объявить ассоциативный массив (требует Bash версии 4.0+).
declare -A user
user[name]="Bob"
user[age]=25
echo ${user[name]} # Выведет "Bob"

# -x : Экспортировать переменную в окружение для дочерних процессов.
declare -x MY_TOOL_PATH="/opt/mytool"
# Теперь переменная MY_TOOL_PATH будет доступна в любом скрипте, запущенном из этого.
```
## Вывод с командой echo:
Если хотим просто вывести переменную : `echo $x` (то есть само использование переменной выражается через знак доллара). Но также мы можем использовать несколько переменных сразу. Например echo $x $name.
Не стоит забывать, что, если мы хотим использовать текст в выводе, нужно помещать все значения в ДВОЙНЫЕ!!! кавычки : `echo "Hi $name . I am $x y.o. And you?"`

С одинарными кавычками переменная не активируется и мы просто выведем текст ( название переменной, вместо её значения).

**Особенности**
Мы можем пользоваться функционалом переменных и в других языках программирования, правда есть фишки вроде того что мы не можем прописать `new=$x+$y` мы получим строковый ответ `2+1`, так как изначально все переменные строковые поэтому мы вычислительное выражение помещаем в две скобки `new=$(($x+$y))`.

## Арифметические операции: подробнее
**Для работы с числами есть несколько способов:**

```bash
x=5
y=3

# Способ 1: $(( ... )) (основной, рекомендуется)
sum=$(($x + $y))       # 8
diff=$((x - y))        # 2. Обрати внимание: знак $ перед именами внутри (()) можно опустить!
mult=$((x * y))        # 15
div=$((x / y))         # 1 (целочисленное деление!)

# Способ 2: let
let "sum = x + y"      # 8
let "x++"              # Инкремент. Теперь x=6

# Способ 3: expr (устаревший, но встречается)
sum=`expr $x + $y`     # 8 (используются обратные кавычки)
```

**Работа со строками**

```bash
text="Hello World"

# Длина строки
echo ${#text}          # 11

# Конкатенация (сложение строк)
greet="Hello, "$name"!" # Или: greet="Hello, ${name}!"

# Извлечение подстроки
echo ${text:0:5}       # "Hello" (с позиции 0 взять 5 символов)
echo ${text:6}         # "World" (с позиции 6 до конца)

# Замена в строке (только первое вхождение)
echo ${text/World/Bash} # "Hello Bash"
# Замена всех вхождений
echo ${text//l/_}      # "He__o Wor_d"
```

**Коды возврата и булева логика**
В Bash "истина" — это код возврата 0, "ложь" — любое число от 1 до 255.

```bash
# Команда 'true' всегда возвращает 0 (успех), 'false' всегда возвращает 1 (ошибка).
if true; then
  echo "Это всегда выполнится"
fi

# Проверка условий осуществляется командами test или [[ ... ]]
x=10
y=20

if [[ $x -lt $y ]]; then  # -lt = less than (<)
  echo "$x меньше $y"
fi

# Логические операции И (&&), ИЛИ (||)
[[ $x -gt 5 ]] && [[ $y -lt 30 ]] && echo "Оба условия истинны"

# Проверка кода возврата последней команды
ls /some/nonexistent/directory
if [[ $? -ne 0 ]]; then  # $? содержит код возврата. -ne = not equal (!=)
  echo "Последняя команда завершилась с ошибкой."
fi
```

**Область видимости (Scope)**
По умолчанию переменные глобальны. Чтобы сделать переменную локальной для функции, используйте ключевое слово `local`.

```bash
global_var="I am global"

my_function() {
  local local_var="I am local"
  global_var="Changed inside function"
  echo "Inside: $local_var, $global_var"
}

my_function
echo "Outside: $local_var, $global_var"
# Выведет:
# Inside: I am local, Changed inside function
# Outside: , Changed inside function
# (local_var пуста, так как она существовала только внутри функции)
```



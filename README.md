# bash_scripting
Записная инструкция и готовые проекты c bash скриптами

## Типичный bash-скрипт имеет простую структуру:

1. **Shebang (#!)**. Первая строка указывает интерпретатор, который будет использоваться, обычно Bash.( `#!/bin/bash`)
2. **Команды**. Серия допустимых команд оболочки, записанных по одной строке.

## Затем чтобы сделать скрипт исполняемым прописываем:
`chmod +x (путь к файлу)` - это даёт разрешение на исполнение

Запускается просто: `./script.sh`

## Переменные
Переменным можно присваивать различные значения:
Числовое значение `x=2` или стринговое значение `x=hi`. Всё пишется слитно с переменной и равно.

**(дополнение)**
### Типы данных в Bash
Bash по своей сути — это оболочка для запуска команд, и она **не имеет строгой типизации** как, например, C++ или Java. Все переменные по умолчанию хранятся как строки (strings). Однако контекст их использования (в арифметических операциях, сравнениях) определяет, как они интерпретируются.

**Основные "типы" на практике:**
1.  **Строка (String):** Значение по умолчанию. `name="Alice"`, `path="/usr/bin"`
2.  **Целое число (Integer):** Для арифметических операций. Создаётся не объявлением, а использованием в арифметическом контексте: `count=5` (хранится как строка "5", но может использоваться как число).
3.  **Массив (Array):** Индексированный список значений. `files=(file1.txt file2.txt)`
4.  **Ассоциативный массив (Associative Array):** Пары "ключ-значение" (как словарь). `declare -A user=([name]="John" [id]=123)`
5.  **"Булевы" значения:** Прямых `true`/`false` нет. Успех или неудача операции определяется **кодом возврата** (`0` = истина/успех, **любое не-нулевое значение** = ложь/ошибка). Для проверок часто используют команды `true` (всегда возвращает 0) и `false` (всегда возвращает 1).

**(дополнение)**
### Объявление и атрибуты переменных
Хотя явно объявить тип `int` нельзя, команда `declare` (или её синонимы `typeset`) позволяет задать переменной особые *атрибуты*, влияющие на её поведение.

```bash
#!/bin/bash

# -i : Интерпретировать переменную как целое число (integer) в арифметических операциях.
declare -i number
number="10"   # Строка "10" будет преобразована в число 10
number="hello" # Если присвоить не-число, оно станет 0
echo $number   # Выведет 0

# -r : Сделать переменную только для чтения (readonly/константа).
declare -r PI=3.14159
# PI=3.14 # Эта строка вызовет ошибку: "readonly variable"

# -a : Объявить индексированный массив.
declare -a colors=("red" "green" "blue")
echo ${colors[1]} # Выведет "green" (индексация с 0)

# -A : Объявить ассоциативный массив (требует Bash версии 4.0+).
declare -A user
user[name]="Bob"
user[age]=25
echo ${user[name]} # Выведет "Bob"

# -x : Экспортировать переменную в окружение для дочерних процессов.
declare -x MY_TOOL_PATH="/opt/mytool"
# Теперь переменная MY_TOOL_PATH будет доступна в любом скрипте, запущенном из этого.
```
## Вывод с командой echo:
Если хотим просто вывести переменную : `echo $x` (то есть само использование переменной выражается через знак доллара). Но также мы можем использовать несколько переменных сразу. Например echo $x $name.
Не стоит забывать, что, если мы хотим использовать текст в выводе, нужно помещать все значения в ДВОЙНЫЕ!!! кавычки : `echo "Hi $name . I am $x y.o. And you?"`

С одинарными кавычками переменная не активируется и мы просто выведем текст ( название переменной, вместо её значения).

**Особенности**
Мы можем пользоваться функционалом переменных и в других языках программирования, правда есть фишки вроде того что мы не можем прописать `new=$x+$y` мы получим строковый ответ `2+1`, так как изначально все переменные строковые поэтому мы вычислительное выражение помещаем в две скобки `new=$(($x+$y))`.

## Арифметические операции: подробнее
**Для работы с числами есть несколько способов:**

```bash
x=5
y=3

# Способ 1: $(( ... )) (основной, рекомендуется)
sum=$(($x + $y))       # 8
diff=$((x - y))        # 2. Обрати внимание: знак $ перед именами внутри (()) можно опустить!
mult=$((x * y))        # 15
div=$((x / y))         # 1 (целочисленное деление!)

# Способ 2: let
let "sum = x + y"      # 8
let "x++"              # Инкремент. Теперь x=6

# Способ 3: expr (устаревший, но встречается)
sum=`expr $x + $y`     # 8 (используются обратные кавычки)
```

**Работа со строками**

```bash
text="Hello World"

# Длина строки
echo ${#text}          # 11

# Конкатенация (сложение строк)
greet="Hello, "$name"!" # Или: greet="Hello, ${name}!"

# Извлечение подстроки
echo ${text:0:5}       # "Hello" (с позиции 0 взять 5 символов)
echo ${text:6}         # "World" (с позиции 6 до конца)

# Замена в строке (только первое вхождение)
echo ${text/World/Bash} # "Hello Bash"
# Замена всех вхождений
echo ${text//l/_}      # "He__o Wor_d"
```

**Коды возврата и булева логика**
В Bash "истина" — это код возврата 0, "ложь" — любое число от 1 до 255.

```bash
# Команда 'true' всегда возвращает 0 (успех), 'false' всегда возвращает 1 (ошибка).
if true; then
  echo "Это всегда выполнится"
fi

# Проверка условий осуществляется командами test или [[ ... ]]
x=10
y=20

if [[ $x -lt $y ]]; then  # -lt = less than (<)
  echo "$x меньше $y"
fi

# Логические операции И (&&), ИЛИ (||)
[[ $x -gt 5 ]] && [[ $y -lt 30 ]] && echo "Оба условия истинны"

# Проверка кода возврата последней команды
ls /some/nonexistent/directory
if [[ $? -ne 0 ]]; then  # $? содержит код возврата. -ne = not equal (!=)
  echo "Последняя команда завершилась с ошибкой."
fi
```

**Область видимости (Scope)**
По умолчанию переменные глобальны. Чтобы сделать переменную локальной для функции, используйте ключевое слово `local`.

```bash
global_var="I am global"

my_function() {
  local local_var="I am local"
  global_var="Changed inside function"
  echo "Inside: $local_var, $global_var"
}

my_function
echo "Outside: $local_var, $global_var"
# Выведет:
# Inside: I am local, Changed inside function
# Outside: , Changed inside function
# (local_var пуста, так как она существовала только внутри функции)
```

### Специальные переменные окружения

Bash автоматически устанавливает ряд полезных переменных окружения. Они доступны в любом скрипте:

- **`BASH`** — полный путь до исполняемого файла Bash.  
  `echo "Я работаю в: $BASH"`

- **`BASH_VERSION`** — версия Bash.  
  `echo "Версия оболочки: $BASH_VERSION"`

- **`HOME`** — домашний каталог текущего пользователя.  
  `echo "Домашняя папка: $HOME"`

- **`HOSTNAME`** — имя компьютера (хоста).  
  `echo "Имя машины: $HOSTNAME"`

- **`RANDOM`** — возвращает случайное число от 0 до 32767 при каждом обращении.  
  `echo "Случайное число: $RANDOM"`

- **`OSTYPE`** — тип операционной системы.  
  `echo "ОС: $OSTYPE"`

- **`PWD`** — текущий рабочий каталог (от **P**rint **W**orking **D**irectory).  
  `echo "Текущая папка: $PWD"`

- **`PS1`** — строка приглашения командной оболочки (то, что ты видишь перед курсором).  
  `echo "Мое приглашение: $PS1"`

- **`UID`** — числовой ID текущего пользователя (0 для root).  
  `[[ $UID -eq 0 ]] && echo "Ты root!" || echo "Ты обычный пользователь"`

- **`USER`** — имя текущего пользователя.  
  `echo "Привет, $USER!"`

**Пример использования:**
```bash
#!/bin/bash
echo "Пользователь $USER (ID: $UID) запустил скрипт из $PWD"
echo "Хост: $HOSTNAME, ОС: $OSTYPE, Bash: $BASH_VERSION"
echo "Сгенерируем случайное число для лотереи: $RANDOM"
```

### Ввод значений во время выполнения скрипта: Команда read
Позволяет получить ввод от пользователя (с клавиатуры) и сохранить его в переменную.

**Базовый синтаксис:**

```bash
read variable_name
После выполнения скрипт ждёт, пока пользователь введёт текст и нажмёт Enter.
```
Пример:

```bash
#!/bin/bash
echo "Как тебя зовут?"
read username
echo "Привет, $username! Добро пожаловать в скрипт."
```
**Дополнительные возможности read:**

```bash
# 1. Запрос с подсказкой (prompt)
read -p "Введите ваш возраст: " age
echo "Вам $age лет"
# 2. Скрытный ввод (для паролей)
read -s -p "Введите пароль: " password
echo  # перенос строки после скрытого ввода
echo "Пароль принят (но не покажу его!)"
# 3. Ввод нескольких значений
read -p "Введите имя и фамилию: " first_name last_name
echo "Имя: $first_name, Фамилия: $last_name"
# 4. Ограничение времени ввода (таймаут)
read -t 10 -p "У вас 10 секунд на ответ: " quick_answer
echo "Вы сказали: ${quick_answer:-ничего}"
```

## Параметры команд
Что такое параметры (аргументы)
**Параметры** — это дополнительные опции и аргументы, которые передаются команде после её имени. Они начинаются с дефиса - или двойного дефиса --.

Типы параметров:

Короткие опции: `-l, -a, -h (один дефис, одна буква)`

Длинные опции: `--help, --version, --all (два дефиса, слова)`

Аргументы: значения, которые передаются опциям или команде

### Примеры популярных команд
1. Универсальные команды (`echo, ls, grep`):

**echo: -n (без переноса строки), -e (интерпретация спецсимволов)**
```bash
echo -n "Текст без переноса "
echo "продолжение"
echo -e "Первая строка\nВторая строка"
```
**ls: -l (подробный список), -a (все файлы), -h (человекочитаемый размер)**
```bash
ls -lah
```
**grep: -i (игнорировать регистр), -r (рекурсивно), -n (показать номера строк)**
```bash
grep -rin "поиск" /путь/к/файлу
```
2. Команды кибербезопасности:

**nmap: -sS (stealth scan), -p (порты), -oN (вывод в файл)**
```bash
nmap -sS -p 22,80,443 192.168.1.1
nmap -sC -sV -oN scan_result.txt target.com
```
**netcat: -l (слушать), -p (порт), -v (подробный вывод)**
```bash
nc -lvp 4444
```
**tcpdump: -i (интерфейс), -c (количество пакетов), -n (не резолвить имена)**
```bash
tcpdump -i eth0 -c 10 -n
```
**openssl: проверка SSL сертификата**
```bash
openssl s_client -connect example.com:443 -servername example.com
```
## Параметры Bash-скриптов
**Позиционные параметры ($1, $2, $3...)**
Когда вы запускаете скрипт с аргументами, они автоматически становятся доступны внутри скрипта как позиционные параметры.

Синтаксис:

```bash
./script.sh аргумент1 аргумент2 аргумент3
# внутри скрипта:
# $1 = "аргумент1"
# $2 = "аргумент2" 
# $3 = "аргумент3"
```
**Базовый пример калькулятора:**
```
```bash
#!/bin/bash
# calculator.sh
sum=$(($1 + $2))
echo "Сумма $1 и $2 равна: $sum"
```
Запуск: `./calculator.sh 12 32 → Вывод: Сумма 12 и 32 равна: 44`

**Все параметры и их особенности**
```bash
#!/bin/bash
# params_demo.sh

echo "Скрипт: $0"           # Имя самого скрипта
echo "Первый параметр: $1"   # $1 - первый аргумент
echo "Второй параметр: $2"   # $2 - второй аргумент
echo "Третий параметр: $3"   # $3 - третий аргумент
```

**До 9 параметра доступны напрямую:**
`$4, $5, $6, $7, $8, $9`

**Параметры с 10 и выше:**
`echo "Десятый параметр: ${10}"`  ** Обязательно в фигурных скобках! **
`echo "Одиннадцатый параметр: ${11}"`

### Специальные переменные:
```bash
echo "Количество параметров: $#"      # $# - общее количество аргументов
echo "Все параметры: $@"              # $@ - все аргументы как отдельные слова
echo "Все параметры: $*"              # $* - все аргументы как одна строка
```
Пример с операциями:

```bash
#!/bin/bash
# advanced_calc.sh
```
Использование: `./advanced_calc.sh 12 + 32`
`result=$(($1 $2 $3))
echo "$1 $2 $3 = $result"`

### Проверка количества параметров
```bash
if [ $# -lt 3 ]; then
  echo "Ошибка: нужно 3 параметра (число операция число)"
  echo "Пример: $0 12 + 32"
  exit 1
fi
```
### Полезные техники работы с параметрами

# 1. Проверка существования параметра
```bash
if [ -z "$1" ]; then
  echo "Первый параметр не указан!"
  exit 1
fi
```
# 2. Перебор всех параметров
```bash
echo "Все переданные аргументы:"
for param in "$@"; do
  echo " - $param"
done
```
# 3. Сдвиг параметров (shift)
```bash
echo "До shift: $@"
shift 2  # Удаляет первые 2 параметра
echo "После shift 2: $@"
```
# 4. Параметры по умолчанию
```bash
filename=${1:-"default.txt"}  # Если $1 пустой, используем "default.txt"
port=${2:-8080}               # Если $2 пустой, используем 8080
echo "Файл: $filename, Порт: $port"
```

**Реальный пример для кибербезопасности**

`#!/bin/bash`
`simple_scanner.sh`
`Использование: ./simple_scanner.sh target.com 80 443 22`

```bash
if [ $# -lt 2 ]; then
  echo "Использование: $0 <хост> <порт1> [порт2] [порт3] ..."
  exit 1
fi
target=$1
shift  # Убираем первый параметр (хост), остаются только порты

echo "Сканирую хост: $target"
echo "Порты для проверки: $@"

for port in "$@"; do
  echo -n "Проверка порта $port: "
  # Имитация проверки (в реальности здесь может быть nc, telnet и т.д.)
  if [[ $((RANDOM % 2)) -eq 0 ]]; then
    echo "ОТКРЫТ"
  else
    echo "ЗАКРЫТ"
  fi
done
```
`Запуск: ./simple_scanner.sh example.com 80 443 22 3389`
